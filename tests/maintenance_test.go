package tests

import (
	"fmt"
	"os/exec"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"github.com/google/go-cmp/cmp"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/ydb-platform/ydb-go-genproto/draft/protos/Ydb_Maintenance"
	"github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Auth"
	"github.com/ydb-platform/ydb-go-genproto/protos/Ydb_Discovery"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/testing/protocmp"

	"github.com/ydb-platform/ydbops/pkg/maintenance"
	blackmagic "github.com/ydb-platform/ydbops/tests/black-magic"
	"github.com/ydb-platform/ydbops/tests/mock"
)

const (
	uuidRegexpString       = "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"
	testWillInsertTaskUuid = "test_will_substitute_this_arg_with_task_uuid"
)

type command []string

var _ = Describe("Test Maintenance", func() {
	var ydb *mock.YdbMock
	var previousEnvVars map[string]string
	commonYdbopsArgs := command{
		"--endpoint", "grpcs://localhost:2135",
		"--verbose",
		"--availability-mode", "strong",
		"--user", mock.TestUser,
		"--cms-query-interval", "1",
		"--ca-file", filepath.Join(".", "test-data", "ssl-data", "ca.crt"),
	}

	type stepData struct {
		expectedRequests      []proto.Message
		expectedOutputRegexps []string
		ydbopsInvocation      command
	}

	type testCase struct {
		nodeConfiguration [][]uint32
		nodeInfoMap       map[uint32]mock.TestNodeInfo

		steps []stepData
	}

	BeforeEach(func() {
		port := 2135
		ydb = mock.NewYdbMockServer()
		ydb.SetupSimpleTLS(
			filepath.Join(".", "test-data", "ssl-data", "ca.crt"),
			filepath.Join(".", "test-data", "ssl-data", "ca_unencrypted.key"),
		)
		ydb.StartOn(port)

		previousEnvVars = prepareEnvVariables()
	})

	AfterEach(func() {
		ydb.Teardown()
		revertEnvVariables(previousEnvVars)
	})

	DescribeTable("restart", func(tc testCase) {
		ydb.SetNodeConfiguration(tc.nodeConfiguration, tc.nodeInfoMap)

		var maintenanceTaskId string
		for _, step := range tc.steps {
			commandArgs := append(commonYdbopsArgs, step.ydbopsInvocation...)
			for i, arg := range commandArgs {
				if arg == testWillInsertTaskUuid {
					// `maintenanceTaskId` is guaranteed to be valid at this point.
					// Look for the commentary where `maintenanceTaskId` is populated.
					commandArgs[i] = maintenanceTaskId
				}
			}
			cmd := exec.Command(filepath.Join("..", "ydbops"), commandArgs...)
			outputBytes, err := cmd.CombinedOutput()
			Expect(err).To(BeNil())
			output := string(outputBytes)

			for _, expectedOutputRegexp := range step.expectedOutputRegexps {
				// This `if` means that `ydbops maintenance create` command has just
				// finished executing. We will extract maintenance task id from it
				// and pass it to the next invocations within this test.
				if strings.Contains(expectedOutputRegexp, "Your task id is:") {
					uuidOnlyRegexp := regexp.MustCompile(
						fmt.Sprintf("(%s%s)",
							maintenance.TaskUuidPrefix,
							uuidRegexpString,
						),
					)
					maintenanceTaskId = uuidOnlyRegexp.FindString(output)
					fmt.Printf("DETERMINED taskId %s\n", maintenanceTaskId)
				}

				r := regexp.MustCompile(expectedOutputRegexp)
				pos := r.FindStringIndex(output)
				if pos == nil {
					Fail(fmt.Sprintf(
						"The required pattern was not found in output.\nPattern:\n%s\nOutput:\n%s",
						expectedOutputRegexp,
						output,
					))
				}
				output = output[pos[1]:]
			}

			actualRequests := ydb.RequestLog
			// Cleanup protobuf log for next step in the test:
			ydb.RequestLog = []proto.Message{}

			// for _, req := range actualRequests {
			// 	fmt.Printf("\n%+v : %+v\n", reflect.TypeOf(req), req)
			// }

			// It is much easier to remove OperationParams field (generated by cms client) than to
			// teach our checker to ignore this field when comparing with mocked answers.
			for _, actualReq := range actualRequests {
				field := reflect.ValueOf(actualReq).Elem().FieldByName("OperationParams")
				if field.IsValid() {
					field.Set(reflect.Zero(field.Type()))
				}
			}

			defer func() {
				if r := recover(); r != nil {
					if strings.Contains(fmt.Sprintf("%v", r), "non-deterministic or non-symmetric function detected") {
						Fail(`UuidComparer failed, see logs for more info.`)
					} else {
						panic(r)
					}
				}
			}()

			expectedPlaceholders := make(map[string]int)
			actualPlaceholders := make(map[string]int)

			Expect(len(step.expectedRequests)).To(Equal(len(actualRequests)))

			for i, expected := range step.expectedRequests {
				actual := actualRequests[i]
				Expect(cmp.Diff(expected, actual,
					protocmp.Transform(),
					blackmagic.ActionGroupSorter(),
					blackmagic.UUIDComparer(expectedPlaceholders, actualPlaceholders),
				)).To(BeEmpty())
			}
		}
	},
		Entry("restart two storage hosts by specifying FQDN, storage-only baremetal cluster", testCase{
			nodeConfiguration: [][]uint32{
				{1, 2, 3, 4, 5, 6, 7, 8},
			},
			nodeInfoMap: map[uint32]mock.TestNodeInfo{},
			steps: []stepData{
				{
					ydbopsInvocation: command{
						"maintenance",
						"create",
						"--hosts=ydb-1.ydb.tech,ydb-2.ydb.tech",
					},
					expectedRequests: []proto.Message{
						&Ydb_Auth.LoginRequest{
							User:     mock.TestUser,
							Password: mock.TestPassword,
						},
						&Ydb_Maintenance.CreateMaintenanceTaskRequest{
							TaskOptions: &Ydb_Maintenance.MaintenanceTaskOptions{
								TaskUid:          "task-uuid-1",
								Description:      "Rolling restart maintenance task",
								AvailabilityMode: Ydb_Maintenance.AvailabilityMode_AVAILABILITY_MODE_STRONG,
							},
							ActionGroups: mock.MakeActionGroupsFromHostFQDNs("ydb-1.ydb.tech", "ydb-2.ydb.tech"),
						},
					},
					expectedOutputRegexps: []string{
						// Your task id is:\n\n<uuid>\n\nPlease write it down for refreshing and completing the task later.\n
						fmt.Sprintf("Your task id is:\n\n%s%s\n\n", maintenance.TaskUuidPrefix, uuidRegexpString),
					},
				},
				{
					ydbopsInvocation: command{
						"maintenance",
						"list",
					},
					expectedRequests: []proto.Message{
						&Ydb_Auth.LoginRequest{
							User:     mock.TestUser,
							Password: mock.TestPassword,
						},
						&Ydb_Discovery.WhoAmIRequest{},
						&Ydb_Maintenance.ListMaintenanceTasksRequest{
							User: &mock.TestUser,
						},
					},
					expectedOutputRegexps: []string{
						fmt.Sprintf("Uid: %s%s\n", maintenance.TaskUuidPrefix, uuidRegexpString),
						"  Lock on host ydb-1.ydb.tech",
						"PERFORMED",
						"  Lock on host ydb-2.ydb.tech",
						"PENDING, (\\S+)",
					},
				},
				{
					ydbopsInvocation: command{
						"maintenance",
						"complete",
						"--task-id",
						testWillInsertTaskUuid,
						"--hosts=ydb-1.ydb.tech",
					},
					expectedRequests: []proto.Message{
						&Ydb_Auth.LoginRequest{
							User:     mock.TestUser,
							Password: mock.TestPassword,
						},
						&Ydb_Maintenance.GetMaintenanceTaskRequest{
							TaskUid: "task-UUID-1",
						},
						&Ydb_Maintenance.CompleteActionRequest{
							ActionUids: []*Ydb_Maintenance.ActionUid{
								{
									TaskUid:  "task-UUID-1",
									GroupId:  "group-UUID-1",
									ActionId: "action-UUID-1",
								},
							},
						},
					},
					expectedOutputRegexps: []string{
						fmt.Sprintf("  Completed action id: %s, status: SUCCESS", uuidRegexpString),
					},
				},
				{
					ydbopsInvocation: command{
						"maintenance",
						"refresh",
						"--task-id",
						testWillInsertTaskUuid,
					},
					expectedRequests: []proto.Message{
						&Ydb_Auth.LoginRequest{
							User:     mock.TestUser,
							Password: mock.TestPassword,
						},
						&Ydb_Maintenance.RefreshMaintenanceTaskRequest{
							TaskUid: "task-uuid-1",
						},
					},
					expectedOutputRegexps: []string{
						fmt.Sprintf("Uid: %s%s\n", maintenance.TaskUuidPrefix, uuidRegexpString),
						"  Lock on host ydb-2.ydb.tech",
						"PERFORMED",
					},
				},
				{
					ydbopsInvocation: command{
						"maintenance",
						"complete",
						"--task-id",
						testWillInsertTaskUuid,
						"--hosts=ydb-2.ydb.tech",
					},
					expectedRequests: []proto.Message{
						&Ydb_Auth.LoginRequest{
							User:     mock.TestUser,
							Password: mock.TestPassword,
						},
						&Ydb_Maintenance.GetMaintenanceTaskRequest{
							TaskUid: "task-UUID-1",
						},
						&Ydb_Maintenance.CompleteActionRequest{
							ActionUids: []*Ydb_Maintenance.ActionUid{
								{
									TaskUid:  "task-UUID-1",
									GroupId:  "group-UUID-1",
									ActionId: "action-UUID-2",
								},
							},
						},
					},
					expectedOutputRegexps: []string{
						fmt.Sprintf("  Completed action id: %s, status: SUCCESS", uuidRegexpString),
					},
				},
				{
					ydbopsInvocation: command{
						"maintenance",
						"list",
					},
					expectedRequests: []proto.Message{
						&Ydb_Auth.LoginRequest{
							User:     mock.TestUser,
							Password: mock.TestPassword,
						},
						&Ydb_Discovery.WhoAmIRequest{},
						&Ydb_Maintenance.ListMaintenanceTasksRequest{
							User: &mock.TestUser,
						},
					},
					expectedOutputRegexps: []string{
						"There are no maintenance tasks",
					},
				},
			},
		},
		),
	)
})
